// Zoni - Retrieval-Augmented Generation Framework for Swift
//
// Embedding type for vector representations of text in vector stores.

// MARK: - Embedding

/// A vector representation of text for semantic similarity operations.
///
/// `Embedding` stores a high-dimensional vector generated by an embedding model,
/// along with optional metadata about the model used. It provides common vector
/// math operations needed for similarity search.
///
/// Example usage:
/// ```swift
/// let embedding1 = Embedding(vector: [0.1, 0.2, 0.3], model: "text-embedding-3-small")
/// let embedding2 = Embedding(vector: [0.15, 0.25, 0.35])
///
/// let similarity = embedding1.cosineSimilarity(to: embedding2)
/// let distance = embedding1.euclideanDistance(to: embedding2)
/// ```
public struct Embedding: Sendable, Codable, Equatable {
    /// The vector representation as an array of floating-point values.
    public let vector: [Float]

    /// The model used to generate this embedding, if known.
    public let model: String?

    /// The number of dimensions in the vector.
    ///
    /// This is equivalent to `vector.count`.
    public var dimensions: Int {
        vector.count
    }

    /// Creates a new embedding with the given vector and optional model identifier.
    ///
    /// - Parameters:
    ///   - vector: The vector representation as an array of floats.
    ///   - model: The model used to generate this embedding (optional).
    public init(vector: [Float], model: String? = nil) {
        self.vector = vector
        self.model = model
    }
}

// MARK: - Vector Math Operations

extension Embedding {
    /// Computes the cosine similarity between this embedding and another.
    ///
    /// Cosine similarity measures the angle between two vectors, returning a value
    /// in the range [-1, 1] where:
    /// - 1 means the vectors point in the same direction (identical)
    /// - 0 means the vectors are orthogonal (unrelated)
    /// - -1 means the vectors point in opposite directions
    ///
    /// Formula: `dot(a, b) / (||a|| * ||b||)`
    ///
    /// - Parameter other: The embedding to compare with.
    /// - Returns: The cosine similarity value, or 0.0 if dimensions don't match
    ///   or either vector has zero magnitude.
    public func cosineSimilarity(to other: Embedding) -> Float {
        // Return 0.0 if dimensions don't match
        guard vector.count == other.vector.count else {
            return 0.0
        }

        // Handle empty vectors
        guard !vector.isEmpty else {
            return 0.0
        }

        let dot = dotProduct(with: other)
        let magnitudeProduct = magnitude() * other.magnitude()

        // Handle zero magnitude (avoid division by zero)
        guard magnitudeProduct > 0 else {
            return 0.0
        }

        return dot / magnitudeProduct
    }

    /// Computes the Euclidean distance between this embedding and another.
    ///
    /// Euclidean distance is the straight-line distance between two points
    /// in the vector space.
    ///
    /// Formula: `sqrt(sum((a[i] - b[i])^2))`
    ///
    /// - Parameter other: The embedding to measure distance to.
    /// - Returns: The Euclidean distance, or `Float.infinity` if dimensions don't match.
    public func euclideanDistance(to other: Embedding) -> Float {
        // Return infinity if dimensions don't match
        guard vector.count == other.vector.count else {
            return Float.infinity
        }

        // Handle empty vectors
        guard !vector.isEmpty else {
            return 0.0
        }

        var sumSquaredDifferences: Float = 0.0

        for i in 0..<vector.count {
            let difference = vector[i] - other.vector[i]
            sumSquaredDifferences += difference * difference
        }

        return sumSquaredDifferences.squareRoot()
    }

    /// Computes the dot product of this embedding with another.
    ///
    /// The dot product is the sum of the element-wise products of two vectors.
    ///
    /// Formula: `sum(a[i] * b[i])`
    ///
    /// - Parameter other: The embedding to compute the dot product with.
    /// - Returns: The dot product, or 0.0 if dimensions don't match.
    public func dotProduct(with other: Embedding) -> Float {
        // Return 0.0 if dimensions don't match
        guard vector.count == other.vector.count else {
            return 0.0
        }

        var sum: Float = 0.0

        for i in 0..<vector.count {
            sum += vector[i] * other.vector[i]
        }

        return sum
    }

    /// Computes the magnitude (length) of this embedding vector.
    ///
    /// The magnitude is the Euclidean norm of the vector.
    ///
    /// Formula: `sqrt(sum(v[i]^2))`
    ///
    /// - Returns: The magnitude of the vector, or 0.0 for an empty vector.
    public func magnitude() -> Float {
        guard !vector.isEmpty else {
            return 0.0
        }

        var sumSquares: Float = 0.0

        for value in vector {
            sumSquares += value * value
        }

        return sumSquares.squareRoot()
    }

    /// Returns a normalized version of this embedding (unit vector).
    ///
    /// A normalized vector has a magnitude of 1.0 while preserving its direction.
    /// Normalizing embeddings is useful for cosine similarity comparisons.
    ///
    /// - Returns: A new embedding with the same direction but magnitude of 1.0,
    ///   or the original embedding if it has zero magnitude.
    public func normalized() -> Embedding {
        let mag = magnitude()

        // Return original if zero magnitude (can't normalize)
        guard mag > 0 else {
            return self
        }

        var normalizedVector = [Float](repeating: 0.0, count: vector.count)

        for i in 0..<vector.count {
            normalizedVector[i] = vector[i] / mag
        }

        return Embedding(vector: normalizedVector, model: model)
    }
}

// MARK: - CustomStringConvertible

extension Embedding: CustomStringConvertible {
    public var description: String {
        let modelInfo = model.map { ", model: \"\($0)\"" } ?? ""
        if vector.count <= 5 {
            return "Embedding(dimensions: \(dimensions), vector: \(vector)\(modelInfo))"
        } else {
            let preview = vector.prefix(3).map { String(format: "%.4f", $0) }.joined(separator: ", ")
            return "Embedding(dimensions: \(dimensions), vector: [\(preview), ...]\(modelInfo))"
        }
    }
}

// MARK: - Hashable

extension Embedding: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(vector)
        hasher.combine(model)
    }
}
